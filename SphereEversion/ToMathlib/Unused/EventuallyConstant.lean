/-
Copyright (c) 2022 Floris van Doorn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Floris van Doorn

! This file was ported from Lean 3 source module to_mathlib.unused.eventually_constant
-/
import Mathbin.Data.Nat.Lattice
import Mathbin.Topology.Separation

/-!
# Eventually constant sequences

Related: `monotonic_sequence_limit_index`
-/


-- in mathlib, this should probably import
-- import order.filter.at_top_bot
-- and topology.separation should import this
-- import topology.basic
open scoped Topology

-- move
theorem ContinuousWithinAt.congr_nhds {Œ± Œ≤} [TopologicalSpace Œ±] [TopologicalSpace Œ≤] {f f‚ÇÅ : Œ± ‚Üí Œ≤}
    {s : Set Œ±} {x : Œ±} (h : ContinuousWithinAt f s x) (h‚ÇÅ : f‚ÇÅ =·∂†[ùìù x] f) :
    ContinuousWithinAt f‚ÇÅ s x :=
  h.congr_of_eventuallyEq (nhdsWithin_le_nhds h‚ÇÅ) h‚ÇÅ.self_of_nhds

namespace Set

-- move
variable {Œ± Œ≤ Œ≥ : Type _} {s t : Set Œ±} {f : s ‚Üí Œ≤} {g : t ‚Üí Œ≤} {x : Œ±}

/-- The union `f ‚à™ g` of two functions `f : s ‚Üí Œ≤` and `g : t ‚Üí Œ≤`.
  On the intersection `s ‚à© t`, the function `f ‚à™ g` corresponds to `f`. -/
def unionElim [DecidablePred (¬∑ ‚àà s)] (f : s ‚Üí Œ≤) (g : t ‚Üí Œ≤) (x : s ‚à™ t) : Œ≤ :=
  if h : (x : Œ±) ‚àà s then f ‚ü®x, h‚ü© else g ‚ü®x, x.Prop.resolve_left h‚ü©

theorem unionElim_eq_left [DecidablePred (¬∑ ‚àà s)] (hx : x ‚àà s) :
    unionElim f g ‚ü®x, mem_union_left _ hx‚ü© = f ‚ü®x, hx‚ü© :=
  dif_pos hx

theorem unionElim_eq_right [DecidablePred (¬∑ ‚àà s)] (h1x : x ‚àà s ‚à™ t) (h2x : x ‚àâ s) :
    unionElim f g ‚ü®x, h1x‚ü© = g ‚ü®x, h1x.resolve_left h2x‚ü© :=
  dif_neg h2x

theorem unionElim_eq_right_of_eq [DecidablePred (¬∑ ‚àà s)] (hxt : x ‚àà t)
    (hfg : ‚àÄ (x) (hxs : x ‚àà s) (hxt : x ‚àà t), f ‚ü®x, hxs‚ü© = g ‚ü®x, hxt‚ü©) :
    unionElim f g ‚ü®x, mem_union_right _ hxt‚ü© = g ‚ü®x, hxt‚ü© :=
  if hxs : x ‚àà s then (unionElim_eq_left hxs).trans (hfg x hxs hxt) else unionElim_eq_right _ hxs

theorem unionElim_restrict [DecidablePred (¬∑ ‚àà s)] (f : Œ± ‚Üí Œ≤) :
    unionElim (s.restrict f) (t.restrict f) = (s ‚à™ t).restrict f :=
  by
  ext ‚ü®x, hx‚ü©
  cases (mem_union _ _ _).mp hx <;> simp [union_elim_eq_left, union_elim_eq_right_of_eq, h]

end Set

open scoped Classical

open Set

namespace Filter

variable {Œ± Œ≤ Œ≥ : Type _} {g : Œ± ‚Üí Œ≤} {f : Filter Œ±} {x : Œ±} {y : Œ≤}

/-- The proposition that a function is eventually constant along a fitler on the domain. -/
def EventuallyConstant (g : Œ± ‚Üí Œ≤) (f : Filter Œ±) : Prop :=
  ‚àÉ y : Œ≤, ‚àÄ·∂† x in f, g x = y

theorem eventuallyConstant_iff_tendsto : EventuallyConstant g f ‚Üî ‚àÉ x : Œ≤, Tendsto g f (pure x) :=
  by simp_rw [eventually_constant, tendsto_pure]

theorem EventuallyConstant.nonempty (h : EventuallyConstant g f) : Nonempty Œ≤ :=
  nonempty_of_exists h

theorem eventuallyConstant_const (y‚ÇÄ : Œ≤) : EventuallyConstant (fun x => y‚ÇÄ) f :=
  ‚ü®y‚ÇÄ, eventually_of_forall fun x => rfl‚ü©

theorem eventuallyConstant_of_unique [Unique Œ≤] : EventuallyConstant g f :=
  ‚ü®default, eventually_of_forall fun x => Unique.uniq _ _‚ü©

theorem eventuallyConstant_atTop [SemilatticeSup Œ±] [Nonempty Œ±] :
    (‚àÉ i, ‚àÄ j, i ‚â§ j ‚Üí g j = g i) ‚Üî EventuallyConstant g atTop :=
  by
  simp_rw [eventually_constant, eventually_at_top]
  constructor
  ¬∑ rintro ‚ü®i, hi‚ü©; refine' ‚ü®g i, i, hi‚ü©
  ¬∑ rintro ‚ü®y, i, hi‚ü©; use i; simp_rw [hi i le_rfl]; exact hi

theorem eventuallyConstant_atTop_nat {g : ‚Ñï ‚Üí Œ±} :
    (‚àÉ n, ‚àÄ m, n ‚â§ m ‚Üí g (m + 1) = g m) ‚Üî EventuallyConstant g atTop :=
  by
  rw [‚Üê eventually_constant_at_top]
  apply exists_congr; intro n
  constructor
  ¬∑ intro h m hm; induction' hm with m hm ih; rfl; rw [Nat.succ_eq_add_one, h m hm, ih]
  ¬∑ intro h m hm; rw [h m hm, h (m + 1) hm.step]

theorem EventuallyConstant.compose (h : EventuallyConstant g f) (g' : Œ≤ ‚Üí Œ≥) :
    EventuallyConstant (g' ‚àò g) f := by cases' h with y hy;
  exact ‚ü®g' y, hy.mono fun x => congr_arg g'‚ü©

theorem EventuallyConstant.apply {Œπ : Type _} {p : Œπ ‚Üí Type _} {g : Œ± ‚Üí ‚àÄ x, p x}
    (h : EventuallyConstant g f) (i : Œπ) : EventuallyConstant (fun x => g x i) f :=
  h.compose fun p => p i

/-- The eventual value of an eventually-constant function.

For convenience, `eventual_value` may be applied to any function; if the input is not
eventually-constant the result should be regarded as a "junk" value. -/
noncomputable def eventualValue [Nonempty Œ≤] (g : Œ± ‚Üí Œ≤) (f : Filter Œ±) : Œ≤ :=
  Classical.epsilon fun x : Œ≤ => ‚àÄ·∂† i in f, g i = x

theorem eventually_eq_eventualValue (h : EventuallyConstant g f) :
    ‚àÄ·∂† i in f, g i = @eventualValue _ _ h.Nonempty g f :=
  Classical.epsilon_spec h

theorem eventualValue_unique [f.ne_bot] {y : Œ≤} (hy : ‚àÄ·∂† i in f, g i = y) :
    y = @eventualValue _ _ ‚ü®y‚ü© g f := by
  obtain ‚ü®x, rfl, hx‚ü© := (hy.and <| eventually_eq_eventual_value ‚ü®y, hy‚ü©).exists; exact hx

/-- This lemma is sometimes useful if the elaborator uses the nonempty instance in
  `eventual_value_unique` to find the implicit argument `y`. -/
theorem eventualValue_unique' [f.ne_bot] {hŒ≤ : Nonempty Œ≤} {y : Œ≤} (hy : ‚àÄ·∂† i in f, g i = y) :
    eventualValue g f = y :=
  (eventualValue_unique hy).symm

theorem eventualValue_eq_fn {g : ‚Ñï ‚Üí Œ≤} {hŒ≤ : Nonempty Œ≤} {n : ‚Ñï} (h : ‚àÄ m, n ‚â§ m ‚Üí g m = g n) :
    eventualValue g atTop = g n :=
  eventualValue_unique' <| eventually_of_mem (mem_atTop _) h

theorem EventuallyConstant.exists_eventualValue_eq [f.ne_bot] (h : EventuallyConstant g f) :
    ‚àÉ i, @eventualValue _ _ h.Nonempty g f = g i :=
  by
  obtain ‚ü®y, hy‚ü© := h
  obtain ‚ü®x, rfl‚ü© := hy.exists
  exact ‚ü®x, (eventual_value_unique hy).symm‚ü©

theorem EventuallyConstant.tendsto [Nonempty Œ≤] (h : EventuallyConstant g f) :
    Tendsto g f (pure (eventualValue g f)) := by rw [tendsto_pure];
  exact eventually_eq_eventual_value h

theorem eventualValue_compose [f.ne_bot] (h : EventuallyConstant g f) (g' : Œ≤ ‚Üí Œ≥) :
    @eventualValue _ _ (h.compose g').Nonempty (g' ‚àò g) f =
      g' (@eventualValue _ _ h.Nonempty g f) :=
  (eventualValue_unique <| (eventually_eq_eventualValue h).mono fun x => congr_arg g').symm

theorem eventualValue_apply {Œπ : Type _} {p : Œπ ‚Üí Type _} [f.ne_bot] {g : Œ± ‚Üí ‚àÄ x, p x}
    (h : EventuallyConstant g f) (i : Œπ) :
    @eventualValue _ _ h.Nonempty g f i =
      @eventualValue _ _ (h.apply i).Nonempty (fun x => g x i) f :=
  (eventualValue_compose h fun p => p i).symm

theorem EventuallyConstant.tendsto_nhds [Nonempty Œ≤] [TopologicalSpace Œ≤]
    (h : EventuallyConstant g f) : Tendsto g f (ùìù (eventualValue g f)) :=
  h.Tendsto.mono_right <| pure_le_nhds _

/-- todo: generalize to `t1_space`. -/
theorem eventualValue_eq_limUnder [f.ne_bot] [Nonempty Œ≤] [TopologicalSpace Œ≤] [T2Space Œ≤]
    (h : EventuallyConstant g f) : eventualValue g f = limUnder f g :=
  h.tendsto_nhds.limUnder_eq.symm

-- the following can be generalized a lot using `eventually_constant.exists_eventual_value_eq`.
-- /-- The index from where a function `g : ‚Ñï ‚Üí Œ±` is eventually constant. Equals `0` if `g` is not
--   eventually constant. -/
-- noncomputable def eventual_index (g : ‚Ñï ‚Üí Œ±) : ‚Ñï :=
-- Inf {n : ‚Ñï | ‚àÄ m, n ‚â§ m ‚Üí g m = g n}
-- lemma eventually_constant.eq_eventual_index {g : ‚Ñï ‚Üí Œ±} (hg : eventually_constant g at_top) {n : ‚Ñï}
--   (hn : eventual_index g ‚â§ n) : g n = g (eventual_index g) :=
-- nat.Inf_mem (eventually_constant_at_top.mpr hg) n hn
-- lemma eventually_constant.fn_eventual_index {g : ‚Ñï ‚Üí Œ±} (hg : eventually_constant g at_top) :
--   g (eventual_index g) = @eventual_value _ _ ‚ü®g 0‚ü© g at_top :=
-- (eventual_value_eq_fn $ Œª n hn, (hg.eq_eventual_index hn : _)).symm
-- lemma eventually_constant.eq_eventual_value_of_eventual_index_le {g : ‚Ñï ‚Üí Œ±}
--   (hg : eventually_constant g at_top) {n : ‚Ñï}
--   (hn : eventual_index g ‚â§ n) : g n = @eventual_value _ _ ‚ü®g 0‚ü© g at_top :=
-- (hg.eq_eventual_index hn).trans hg.fn_eventual_index
-- lemma foo {g : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {s : set Œ≤} (hg : eventually_constant (Œª n, s.restrict (g n)) f)
--   (hy : y ‚àà s) :
-- unproved
end Filter

open Filter

variable {Œ± Œ≤ Œ≥ Œ¥ : Type _} {g : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {f : Filter Œ±} {O U : Set Œ≤} {i : Œ±} {x : Œ≤}

section EventuallyConstantOn

/-- A sequence of functions `g` is eventually constant on `O` w.r.t. filter `f` if
  `g` restricted to `O` is eventually constant.
-/
def EventuallyConstantOn (g : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (f : Filter Œ±) (O : Set Œ≤) : Prop :=
  EventuallyConstant (fun n => O.restrict (g n)) f

theorem EventuallyConstantOn.eventuallyConstant (hg : EventuallyConstantOn g f O) (hx : x ‚àà O) :
    EventuallyConstant (fun n => g n x) f := by cases' hg with y hg;
  exact ‚ü®y ‚ü®x, hx‚ü©, hg.mono fun n hn => (function.funext_iff.mp hn ‚ü®x, hx‚ü© : _)‚ü©

theorem EventuallyConstantOn.nonempty (hg : EventuallyConstantOn g f O) (hx : x ‚àà O) : Nonempty Œ≥ :=
  (hg.EventuallyConstant hx).Nonempty

theorem eventuallyConstantOn_atTop [SemilatticeSup Œ±] [Nonempty Œ±] :
    (‚àÉ x, ‚àÄ x', x ‚â§ x' ‚Üí ‚àÄ y ‚àà O, g x' y = g x y) ‚Üî EventuallyConstantOn g atTop O := by
  simp_rw [EventuallyConstantOn, ‚Üê eventually_constant_at_top, restrict_eq_restrict_iff, eq_on]

theorem EventuallyConstantOn.exists_eventualValue_eq [f.ne_bot] (hg : EventuallyConstantOn g f O) :
    ‚àÉ i, ‚àÄ (x) (hx : x ‚àà O), @eventualValue _ _ (hg.Nonempty hx) (fun n => g n x) f = g i x := by
  simpa only [@eq_restrict_iff Œ≤ fun _ => Œ≥, eventual_value_apply hg] using
    hg.exists_eventual_value_eq

-- lemma eventually_constant_on.exists_eventual_value_eq [f.ne_bot] (h : eventually_constant g f) :
--   ‚àÉ x, @eventual_value _ _ h.nonempty g f = g x :=
-- begin
--   obtain ‚ü®y, hy‚ü© := h,
--   obtain ‚ü®x, rfl‚ü© := hy.exists,
--   exact ‚ü®x, (eventual_value_unique hy).symm‚ü©
-- end
end EventuallyConstantOn

variable [TopologicalSpace Œ≤]

section LocallyEventuallyConstant

/-- A sequence of functions `g` is locally eventually constant on `U` w.r.t. filter `f` if
  every point in `U` has a neighborhood `O` such that `g` restricted to `O` is eventually constant.
-/
def LocallyEventuallyConstantOn (g : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (f : Filter Œ±) (U : Set Œ≤) : Prop :=
  ‚àÄ x ‚àà U, ‚àÉ O ‚àà ùìù x, EventuallyConstantOn g f O

theorem LocallyEventuallyConstantOn.eventuallyConstant (hgf : LocallyEventuallyConstantOn g f U)
    (hx : x ‚àà U) : EventuallyConstant (fun n => g n x) f := by obtain ‚ü®O, hO, hg‚ü© := hgf x hx;
  exact hg.eventually_constant (mem_of_mem_nhds hO)

theorem LocallyEventuallyConstantOn.nonempty (hg : LocallyEventuallyConstantOn g f U) (hx : x ‚àà U) :
    Nonempty Œ≥ :=
  (hg.EventuallyConstant hx).Nonempty

theorem LocallyEventuallyConstantOn.continuousWithinAt [TopologicalSpace Œ¥] [f.ne_bot] [Nonempty Œ¥]
    (F : Œ≥ ‚Üí Œ¥) (hgf : LocallyEventuallyConstantOn g f U) (hxU : x ‚àà U)
    (hg : ‚àÄ i, ContinuousWithinAt (F ‚àò g i) U x) :
    ContinuousWithinAt (fun x => eventualValue (fun i => F (g i x)) f) U x :=
  by
  obtain ‚ü®O, hO, hgO‚ü© := hgf x hxU
  obtain ‚ü®i, hi‚ü© := (eventually_eq_eventual_value hgO).exists
  simp_rw [Function.funext_iff, eventual_value_apply hgO] at hi 
  refine' (hg i).congr_nhds (eventually_of_mem hO fun y (hy : y ‚àà O) => _)
  refine' Eq.trans _ (congr_arg F <| hi ‚ü®y, hy‚ü©).symm
  apply eventual_value_compose

theorem LocallyEventuallyConstantOn.exists_nhdsSet_of_isCompact
    (hgf : LocallyEventuallyConstantOn g f U) {K : Set Œ≤} (hK : IsCompact K) (hKU : K ‚äÜ U) :
    ‚àÉ O ‚àà ùìùÀ¢ K, EventuallyConstantOn g f O :=
  by
  refine' IsCompact.induction_on hK ‚ü®‚àÖ, mem_nhdsSet_empty, eventually_constant_of_unique‚ü© _ _ _
  ¬∑ rintro s t hst ‚ü®O, hO, hgO‚ü©; refine' ‚ü®O, _, hgO‚ü©; exact monotone_nhdsSet hst hO
  ¬∑ rintro s t ‚ü®O, hO, y, hgO‚ü© ‚ü®O', hO', y', hgO'‚ü©
    refine' ‚ü®O ‚à™ O', union_mem_nhdsSet hO hO', union_elim y y', _‚ü©
    filter_upwards [hgO, hgO']; rintro x rfl rfl
    rw [union_elim_restrict]
  ¬∑ intro x hx; rcases hgf x (hKU hx) with ‚ü®O, hO, hgO‚ü©
    exact
      ‚ü®interior O, mem_nhdsWithin_of_mem_nhds <| interior_mem_nhds.mpr hO, O, mem_nhdsSet_interior,
        hgO‚ü©

/-- A neighborhood around `x` where `g` is locally constant. -/
def LocallyEventuallyConstantOn.nhd (hgf : LocallyEventuallyConstantOn g f U) (hx : x ‚àà U) :
    Set Œ≤ :=
  Classical.choose <| hgf x hx

theorem LocallyEventuallyConstantOn.nhd_mem_nhds (hgf : LocallyEventuallyConstantOn g f U)
    (hx : x ‚àà U) : hgf.nhd hx ‚àà ùìù x :=
  Classical.choose <| Classical.choose_spec <| hgf x hx

theorem LocallyEventuallyConstantOn.eventually_constant_nhd
    (hgf : LocallyEventuallyConstantOn g f U) (hx : x ‚àà U) :
    EventuallyConstantOn g f (hgf.nhd hx) :=
  Classical.choose_spec <| Classical.choose_spec <| hgf x hx

end LocallyEventuallyConstant

