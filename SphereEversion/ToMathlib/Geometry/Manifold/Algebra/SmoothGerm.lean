import Mathlib.Geometry.Manifold.Algebra.SmoothFunctions
import Mathlib.Geometry.Manifold.MFDeriv.Basic
import SphereEversion.ToMathlib.Topology.Germ

noncomputable section

open Filter Set

open scoped Manifold Topology BigOperators

-- to smooth_functions
section

variable {ùïú : Type _} [NontriviallyNormedField ùïú] {E : Type _} [NormedAddCommGroup E]
  [NormedSpace ùïú E] {E' : Type _} [NormedAddCommGroup E'] [NormedSpace ùïú E'] {H : Type _}
  [TopologicalSpace H] {I : ModelWithCorners ùïú E H} {H' : Type _} [TopologicalSpace H']
  {I' : ModelWithCorners ùïú E' H'} {N : Type _} [TopologicalSpace N] [ChartedSpace H N]
  {E'' : Type _} [NormedAddCommGroup E''] [NormedSpace ùïú E''] {H'' : Type _} [TopologicalSpace H'']
  {I'' : ModelWithCorners ùïú E'' H''} {N' : Type _} [TopologicalSpace N'] [ChartedSpace H'' N']
  {G : Type _} [CommMonoid G] [TopologicalSpace G] [ChartedSpace H' G] [SmoothMul I' G]

@[to_additive]
theorem SmoothMap.coe_prod {Œπ} (f : Œπ ‚Üí C^‚àû‚üÆI, N; I', G‚üØ) (s : Finset Œπ) :
    ‚áë(‚àè i in s, f i) = ‚àè i in s, ‚áë(f i) :=
  map_prod (SmoothMap.coeFnMonoidHom : C^‚àû‚üÆI, N; I', G‚üØ ‚Üí* N ‚Üí G) f s

end

section

-- This should be in `order.filter.germ` (and the end of the module docstring of that file
-- should be fixed, it currently refers to things that are in the filter_product file).
instance Filter.Germ.orderedCommRing' {Œ± : Type _} (l : Filter Œ±) (R : Type _) [OrderedCommRing R] :
    OrderedCommRing (Germ l R) :=
  { Filter.Germ.partialOrder, inferInstanceAs (CommRing (Germ l R)) with
    add_le_add_left := by
      rintro ‚ü®a‚ü© ‚ü®b‚ü© hab ‚ü®c‚ü©
      exact Eventually.mono hab fun x hx => add_le_add_left hx _
    zero_le_one := eventually_of_forall fun _ => zero_le_one
    mul_nonneg := by
      rintro ‚ü®a‚ü© ‚ü®b‚ü© ha hb
      exact Eventually.mono (ha.and hb) fun x hx => mul_nonneg hx.1 hx.2 }

@[to_additive (attr := simp)]
theorem Germ.coe_prod {Œ± : Type _} (l : Filter Œ±) (R : Type _) [CommMonoid R] {Œπ} (f : Œπ ‚Üí Œ± ‚Üí R)
    (s : Finset Œπ) : ((‚àè i in s, f i : Œ± ‚Üí R) : Germ l R) = ‚àè i in s, (f i : Germ l R) :=
  map_prod (Germ.coeMulHom l : (Œ± ‚Üí R) ‚Üí* Germ l R) f s

variable {E : Type _} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] {E' : Type _} [NormedAddCommGroup E']
  [NormedSpace ‚Ñù E'] {H : Type _} [TopologicalSpace H] (I : ModelWithCorners ‚Ñù E H) {H' : Type _}
  [TopologicalSpace H'] {I' : ModelWithCorners ‚Ñù E' H'} {N : Type _} [TopologicalSpace N]
  [ChartedSpace H N] {E'' : Type _} [NormedAddCommGroup E''] [NormedSpace ‚Ñù E''] {H'' : Type _}
  [TopologicalSpace H''] {I'' : ModelWithCorners ‚Ñù E'' H''} {N' : Type _} [TopologicalSpace N']
  [ChartedSpace H'' N'] (F : Type _) [NormedAddCommGroup F] [NormedSpace ‚Ñù F] (G : Type _)
  [AddCommGroup G] [Module ‚Ñù G]

def RingHom.germOfContMDiffMap (x : N) : C^‚àû‚üÆI, N; ùìò(‚Ñù), ‚Ñù‚üØ ‚Üí+* Germ (ùìù x) ‚Ñù :=
  RingHom.comp (Germ.coeRingHom _) SmoothMap.coeFnRingHom

def smoothGerm (x : N) : Subring (Germ (ùìù x) ‚Ñù) :=
  (RingHom.germOfContMDiffMap I x).range

instance (x : N) : Coe C^‚àû‚üÆI, N; ùìò(‚Ñù), ‚Ñù‚üØ (smoothGerm I x) :=
  ‚ü®fun f => ‚ü®(f : N ‚Üí ‚Ñù), ‚ü®f, rfl‚ü©‚ü©‚ü©

@[simp]
theorem smoothGerm.coe_coe (f : C^‚àû‚üÆI, N; ùìò(‚Ñù), ‚Ñù‚üØ) (x : N) :
    ((f : smoothGerm I x) : (ùìù x).Germ ‚Ñù) = (f : (ùìù x).Germ ‚Ñù) :=
  rfl

@[simp]
theorem smoothGerm.coe_sum {Œπ} (f : Œπ ‚Üí C^‚àû‚üÆI, N; ùìò(‚Ñù), ‚Ñù‚üØ) (s : Finset Œπ) (x : N) :
    ((‚àë i in s, f i : C^‚àû‚üÆI, N; ùìò(‚Ñù), ‚Ñù‚üØ) : smoothGerm I x) = ‚àë i in s, (f i : smoothGerm I x) :=
  map_sum (RingHom.rangeRestrict (RingHom.germOfContMDiffMap I x)) f s

@[simp]
theorem smoothGerm.coe_eq_coe (f g : C^‚àû‚üÆI, N; ùìò(‚Ñù), ‚Ñù‚üØ) {x : N} (h : ‚àÄ·∂† y in ùìù x, f y = g y) :
    (f : smoothGerm I x) = (g : smoothGerm I x) := by
  ext
  apply Quotient.sound
  exact h

example (x : N) : Module (smoothGerm I x) (Germ (ùìù x) G) := by infer_instance

example (x : N) : Module (Germ (ùìù x) ‚Ñù) (Germ (ùìù x) F) := by infer_instance

-- def linear_map.germ_of_cont_mdiff_map (x : N) :
--   C^‚àû‚üÆI, N; ùìò(‚Ñù, F), F‚üØ ‚Üí‚Çõ‚Çó[(germ.coe_ring_hom (ùìù x) : (N ‚Üí ‚Ñù) ‚Üí+* germ (ùìù x) ‚Ñù).comp (pi.const_ring_hom N ‚Ñù)] germ (ùìù x) F :=
-- sorry -- linear_map.comp (germ.coe_linear_map _) smooth_map.coe_fn_linear_map
/-
def smooth_germ_vec (x : N) : submodule (smooth_germ I x) (germ (ùìù x) F) :=
-- linear_map.range (linear_map.germ_of_cont_mdiff_map I F x)
{ carrier := {œÜ : germ (ùìù x) F | ‚àÉ f : C^‚àû‚üÆI, N; ùìò(‚Ñù, F), F‚üØ, œÜ = (f : N ‚Üí F)},
  add_mem' := sorry,
  zero_mem' := sorry,
  smul_mem' := sorry }

instance (x : N) : has_coe C^‚àû‚üÆI, N; ùìò(‚Ñù, F), F‚üØ (smooth_germ_vec I F x) :=
‚ü®Œª f, ‚ü®(f : N ‚Üí F), ‚ü®f, rfl‚ü©‚ü©‚ü©

variables {I F}

@[elab_as_eliminator]
lemma smooth_germ_vec.induction_on {x : N} {P : germ (ùìù x) F ‚Üí Prop}
  (h : ‚àÄ  f : C^‚àû‚üÆI, N; ùìò(‚Ñù, F), F‚üØ, P (f : N ‚Üí F)) :
  ‚àÄ œÜ ‚àà smooth_germ_vec I F x, P œÜ :=
begin
  rintros _ ‚ü®f, rfl‚ü©,
  apply h
end

@[elab_as_eliminator]
lemma smooth_germ.induction_on {x : N} {P : germ (ùìù x) ‚Ñù ‚Üí Prop}
  (h : ‚àÄ  f : C^‚àû‚üÆI, N; ùìò(‚Ñù), ‚Ñù‚üØ, P (f : N ‚Üí ‚Ñù)) :
  ‚àÄ œÜ ‚àà smooth_germ I x, P œÜ :=
begin
  rintros _ ‚ü®f, rfl‚ü©,
  apply h
end

-- We may also need versions of the above two lemmas for using the coe_to_sort
-- `‚àÄ œÜ : smooth_germ I x`, maybe even a tactic, but let's wait to see if they are really needed.

lemma convex_smooth_germ_vec (x : N) : convex (smooth_germ I x)
  (smooth_germ_vec I F x : set $ germ (ùìù x) F) :=
begin
  refine smooth_germ_vec.induction_on _,
  intros f,
  refine smooth_germ_vec.induction_on _,
  rintros g ‚ü®_, ‚ü®b, rfl‚ü©‚ü© ‚ü®_, ‚ü®c, rfl‚ü©‚ü© hb hc hbc,
  exact ‚ü®b ‚Ä¢ f + c ‚Ä¢ g, rfl‚ü©,
end
-/
end

section

variable {Œπ : Type _}

variable {E : Type _} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [FiniteDimensional ‚Ñù E] {H : Type _}
  [TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type _} [TopologicalSpace M]
  [ChartedSpace H M] [SmoothManifoldWithCorners I M] [SigmaCompactSpace M] [T2Space M]

variable {F : Type _} [NormedAddCommGroup F] [NormedSpace ‚Ñù F]

variable {G : Type _} [NormedAddCommGroup G] [NormedSpace ‚Ñù G] {HG : Type _} [TopologicalSpace HG]
  (IG : ModelWithCorners ‚Ñù G HG) {N : Type _} [TopologicalSpace N] [ChartedSpace HG N]
  [SmoothManifoldWithCorners IG N]

local notation "ùìí" => ContMDiff I ùìò(‚Ñù, F)

local notation "ùìí_on" => ContMDiffOn I ùìò(‚Ñù, F)

def smoothGerm.valueOrderRingHom (x : N) : smoothGerm IG x ‚Üí+*o ‚Ñù :=
  Filter.Germ.valueOrderRingHom.comp <| Subring.orderedSubtype _

def smoothGerm.valueRingHom (x : N) : smoothGerm IG x ‚Üí+* ‚Ñù :=
  Filter.Germ.valueRingHom.comp <| Subring.subtype _

theorem smoothGerm.valueOrderRingHom_toRingHom (x : N) :
    (smoothGerm.valueOrderRingHom IG x).toRingHom = smoothGerm.valueRingHom IG x :=
  rfl

def Filter.Germ.value‚Çõ‚Çó {F} [AddCommMonoid F] [Module ‚Ñù F] (x : N) :
    Germ (ùìù x) F ‚Üí‚Çõ‚Çó[smoothGerm.valueRingHom IG x] F :=
  { Filter.Germ.valueAddHom with
    toFun := Filter.Germ.value
    map_smul' := fun œÜ œà => (œÜ : Germ (ùìù x) ‚Ñù).value_smul œà }

variable (I)

protected def Filter.Germ.ContMDiffAt' {x : M} (œÜ : Germ (ùìù x) N) (n : ‚Ñï‚àû) : Prop :=
  Quotient.liftOn' œÜ (fun f => ContMDiffAt I IG n f x) fun f g h =>
    propext <| by
      constructor
      all_goals refine' fun H => H.congr_of_eventuallyEq _
      exacts [h.symm, h]

/-- The predicate selecting germs of `cont_mdiff_at` functions.
TODO: merge with the next def that generalizes target space -/
protected nonrec def Filter.Germ.ContMDiffAt {x : M} (œÜ : Germ (ùìù x) F) (n : ‚Ñï‚àû) : Prop :=
  œÜ.ContMDiffAt' I ùìò(‚Ñù, F) n

-- currently unused
nonrec def Filter.Germ.mfderiv {x : M} (œÜ : Germ (ùìù x) N) :
    TangentSpace I x ‚ÜíL[‚Ñù] TangentSpace IG œÜ.value :=
  @Quotient.hrecOn _ (germSetoid (ùìù x) N)
    (fun œÜ : Germ (ùìù x) N => TangentSpace I x ‚ÜíL[‚Ñù] TangentSpace IG œÜ.value) œÜ
    (fun f => mfderiv I IG f x) fun _f _g hfg => heq_of_eq (EventuallyEq.mfderiv_eq hfg : _)

variable {I}

theorem smoothGerm.contMDiffAt {x : M} (œÜ : smoothGerm I x) {n : ‚Ñï‚àû} :
    (œÜ : Germ (ùìù x) ‚Ñù).ContMDiffAt I n := by rcases œÜ with ‚ü®_, g, rfl‚ü©; apply g.smooth.of_le le_top

protected nonrec theorem Filter.Germ.ContMDiffAt.add {x : M} {œÜ œà : Germ (ùìù x) F} {n : ‚Ñï‚àû} :
    œÜ.ContMDiffAt I n ‚Üí œà.ContMDiffAt I n ‚Üí (œÜ + œà).ContMDiffAt I n :=
  Germ.inductionOn œÜ fun _f hf => Germ.inductionOn œà fun _g hg => hf.add hg

protected nonrec theorem Filter.Germ.ContMDiffAt.smul {x : M} {œÜ : Germ (ùìù x) ‚Ñù} {œà : Germ (ùìù x) F}
    {n : ‚Ñï‚àû} : œÜ.ContMDiffAt I n ‚Üí œà.ContMDiffAt I n ‚Üí (œÜ ‚Ä¢ œà).ContMDiffAt I n :=
  Germ.inductionOn œÜ fun _f hf => Germ.inductionOn œà fun _g hg => hf.smul hg

theorem Filter.Germ.ContMDiffAt.sum {x : M} {Œπ} {s : Finset Œπ} {n : ‚Ñï‚àû} {f : Œπ ‚Üí Germ (ùìù x) F}
    (h : ‚àÄ i ‚àà s, (f i).ContMDiffAt I n) : (‚àë i in s, f i).ContMDiffAt I n := by
  classical
  induction' s using Finset.induction_on with œÜ s hœÜs hs
  ¬∑ rw [Finset.sum_empty]; exact contMDiffAt_const
  simp only [Finset.mem_insert, forall_eq_or_imp] at h
  rw [Finset.sum_insert hœÜs]
  exact h.1.add (hs h.2)

end

section

variable {E‚ÇÅ E‚ÇÇ E‚ÇÉ E‚ÇÑ F : Type _}

variable [NormedAddCommGroup E‚ÇÅ] [NormedSpace ‚Ñù E‚ÇÅ] [FiniteDimensional ‚Ñù E‚ÇÅ]

variable [NormedAddCommGroup E‚ÇÇ] [NormedSpace ‚Ñù E‚ÇÇ] [FiniteDimensional ‚Ñù E‚ÇÇ]

variable [NormedAddCommGroup E‚ÇÉ] [NormedSpace ‚Ñù E‚ÇÉ] [FiniteDimensional ‚Ñù E‚ÇÉ]

variable [NormedAddCommGroup E‚ÇÑ] [NormedSpace ‚Ñù E‚ÇÑ] [FiniteDimensional ‚Ñù E‚ÇÑ]

variable [NormedAddCommGroup F] [NormedSpace ‚Ñù F]

variable {H‚ÇÅ M‚ÇÅ H‚ÇÇ M‚ÇÇ H‚ÇÉ M‚ÇÉ H‚ÇÑ M‚ÇÑ : Type _}

variable [TopologicalSpace H‚ÇÅ] (I‚ÇÅ : ModelWithCorners ‚Ñù E‚ÇÅ H‚ÇÅ)

variable [TopologicalSpace M‚ÇÅ] [ChartedSpace H‚ÇÅ M‚ÇÅ] [SmoothManifoldWithCorners I‚ÇÅ M‚ÇÅ]

variable [SigmaCompactSpace M‚ÇÅ] [T2Space M‚ÇÅ]

variable [TopologicalSpace H‚ÇÇ] (I‚ÇÇ : ModelWithCorners ‚Ñù E‚ÇÇ H‚ÇÇ)

variable [TopologicalSpace M‚ÇÇ] [ChartedSpace H‚ÇÇ M‚ÇÇ] [SmoothManifoldWithCorners I‚ÇÇ M‚ÇÇ]

variable [TopologicalSpace H‚ÇÉ] (I‚ÇÉ : ModelWithCorners ‚Ñù E‚ÇÉ H‚ÇÉ)

variable [TopologicalSpace M‚ÇÉ] [ChartedSpace H‚ÇÉ M‚ÇÉ] [SmoothManifoldWithCorners I‚ÇÉ M‚ÇÉ]

variable [TopologicalSpace H‚ÇÑ] (I‚ÇÑ : ModelWithCorners ‚Ñù E‚ÇÑ H‚ÇÑ)

variable [TopologicalSpace M‚ÇÑ] [ChartedSpace H‚ÇÑ M‚ÇÑ] [SmoothManifoldWithCorners I‚ÇÑ M‚ÇÑ]

local notation "ùìí" => ContMDiff (I‚ÇÅ.prod I‚ÇÇ) ùìò(‚Ñù, F)

local notation "ùìí_on" => ContMDiffOn (I‚ÇÅ.prod I‚ÇÇ) ùìò(‚Ñù, F)

open scoped Filter

open Function

-- TODO: generalize the next def?
def Filter.Germ.ContMDiffAtProd {x : M‚ÇÅ} (œÜ : Germ (ùìù x) (M‚ÇÇ ‚Üí F)) (n : ‚Ñï‚àû) : Prop :=
  Quotient.liftOn' œÜ (fun f => ‚àÄ y : M‚ÇÇ, ContMDiffAt (I‚ÇÅ.prod I‚ÇÇ) ùìò(‚Ñù, F) n (uncurry f) (x, y))
    fun f g h => propext <| by
        change {x' | f x' = g x'} ‚àà ùìù x at h
        constructor
        all_goals
          refine' fun H y => (H y).congr_of_eventuallyEq _
          clear H
          replace h : {x' | f x' = g x'} √óÀ¢ (univ : Set M‚ÇÇ) ‚àà ùìù x √óÀ¢ ùìù y := prod_mem_prod h univ_mem
          rw [‚Üê nhds_prod_eq] at h
          apply mem_of_superset h
          rintro ‚ü®x', y'‚ü© ‚ü®hx' : f x' = g x', -‚ü©
          simp only [mem_setOf_eq, uncurry_apply_pair]
          apply congr_fun
        exacts [hx'.symm, hx']

/- potential generalization of the above
def filter.germ.cont_mdiff_at_comp {x : M‚ÇÅ} (œÜ : germ (ùìù x) M‚ÇÇ) (n : ‚Ñï‚àû)
  (g : M‚ÇÇ ‚Üí M‚ÇÉ) (h : M‚ÇÑ ‚Üí M‚ÇÅ) : Prop :=
quotient.lift_on' œÜ (Œª f, ‚àÄ y ‚àà h‚Åª¬π' {x}, cont_mdiff_at I‚ÇÑ I‚ÇÉ n (g ‚àò f ‚àò h) y) (Œª f g h, propext begin
  change {x' | f x' = g x'} ‚àà ùìù x at h,
  split,
  all_goals
  { refine Œª H y, (H y).congr_of_eventually_eq _,
    clear H,
    replace h : {x' | f x' = g x'} √óÀ¢ (univ : set M‚ÇÇ) ‚àà (ùìù x) √ó·∂† (ùìù y) := prod_mem_prod h univ_mem,
    rw ‚Üê nhds_prod_eq at h,
    apply mem_of_superset h,
    rintros ‚ü®x', y'‚ü© ‚ü®(hx' : f x' = g x'), -‚ü©,
    simp only [mem_setOf_eq, uncurry_apply_pair],
    apply congr_fun, },
  exacts [hx'.symm, hx']
end)
-/
variable {I‚ÇÅ I‚ÇÇ}

theorem Filter.Germ.ContMDiffAtProd.add {x : M‚ÇÅ} {œÜ œà : Germ (ùìù x) <| M‚ÇÇ ‚Üí F} {n : ‚Ñï‚àû} :
    œÜ.ContMDiffAtProd I‚ÇÅ I‚ÇÇ n ‚Üí œà.ContMDiffAtProd I‚ÇÅ I‚ÇÇ n ‚Üí (œÜ + œà).ContMDiffAtProd I‚ÇÅ I‚ÇÇ n :=
  Germ.inductionOn œÜ fun _f hf => Germ.inductionOn œà fun _g hg y => (hf y).add (hg y)

theorem Filter.Germ.ContMDiffAtProd.smul {x : M‚ÇÅ} {œÜ : Germ (ùìù x) <| M‚ÇÇ ‚Üí ‚Ñù}
    {œà : Germ (ùìù x) <| M‚ÇÇ ‚Üí F} {n : ‚Ñï‚àû} :
    œÜ.ContMDiffAtProd I‚ÇÅ I‚ÇÇ n ‚Üí œà.ContMDiffAtProd I‚ÇÅ I‚ÇÇ n ‚Üí (œÜ ‚Ä¢ œà).ContMDiffAtProd I‚ÇÅ I‚ÇÇ n :=
  Germ.inductionOn œÜ fun _f hf => Germ.inductionOn œà fun _g hg y => (hf y).smul (hg y)

theorem Filter.Germ.ContMDiffAt.smul_prod {x : M‚ÇÅ} {œÜ : Germ (ùìù x) ‚Ñù} {œà : Germ (ùìù x) (M‚ÇÇ ‚Üí F)}
    {n : ‚Ñï‚àû} : œÜ.ContMDiffAt I‚ÇÅ n ‚Üí œà.ContMDiffAtProd I‚ÇÅ I‚ÇÇ n ‚Üí (œÜ ‚Ä¢ œà).ContMDiffAtProd I‚ÇÅ I‚ÇÇ n :=
  Germ.inductionOn œÜ fun _f hf => Germ.inductionOn œà fun _g hg y =>
    .smul (.comp _ hf contMDiffAt_fst) (hg y)

theorem Filter.Germ.ContMDiffAtProd.sum {x : M‚ÇÅ} {Œπ} {s : Finset Œπ} {n : ‚Ñï‚àû}
    {f : Œπ ‚Üí Germ (ùìù x) (M‚ÇÇ ‚Üí F)} (h : ‚àÄ i ‚àà s, (f i).ContMDiffAtProd I‚ÇÅ I‚ÇÇ n) :
    (‚àë i in s, f i).ContMDiffAtProd I‚ÇÅ I‚ÇÇ n := by
  classical
  induction' s using Finset.induction_on with œÜ s hœÜs hs
  ¬∑ rw [Finset.sum_empty]; intro y; exact contMDiffAt_const
  simp only [Finset.mem_insert, forall_eq_or_imp] at h
  rw [Finset.sum_insert hœÜs]
  exact h.1.add (hs h.2)

end
